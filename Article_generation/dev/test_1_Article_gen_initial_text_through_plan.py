from openai import AsyncOpenAI
import requests
import aiohttp
import json
import pandas as pd
from bs4 import BeautifulSoup
from urllib.parse import urlparse
from langchain_community.document_loaders import UnstructuredURLLoader
from sentence_transformers import SentenceTransformer, util
import logging
from aiohttp import ClientSession
import serpstat

from src.config import settings_pr

client = AsyncOpenAI(
    api_key=settings_pr.openai_api_key
)

model = SentenceTransformer('paraphrase-MiniLM-L6-v2')

# Асинхронная функция для вставки заголовка после семантически схожей фразы с обработкой ошибок
async def insert_heading_after_semantic_phrase(text: str, phrase: str, heading: str) -> str:
    try:
        # Проверка входных данных
        if not text or not phrase or not heading:
            raise ValueError("Ошибка: Текст, фраза или заголовок не могут быть пустыми.")
        
        # Разбиваем текст на предложения для поиска места вставки
        sentences = text.split('. ')
        if len(sentences) < 2:
            raise ValueError("Ошибка: Текст слишком короткий для обработки.")

        # Получаем эмбеддинги для фразы и предложений текста
        try:
            phrase_embedding = model.encode(phrase, convert_to_tensor=True)
            sentence_embeddings = model.encode(sentences, convert_to_tensor=True)
        except Exception as e:
            raise RuntimeError(f"Ошибка при создании эмбеддингов: {str(e)}")

        # Находим предложение, которое максимально семантически похоже на фразу
        try:
            cosine_scores = util.pytorch_cos_sim(phrase_embedding, sentence_embeddings)
            best_match_index = cosine_scores.argmax().item()  # Получаем индекс наиболее похожего предложения
        except Exception as e:
            raise RuntimeError(f"Ошибка при вычислении семантической близости: {str(e)}")

        # Разделяем текст на две части: до и после найденного предложения
        before_sentence = '. '.join(sentences[:best_match_index + 1])
        after_sentence = '. '.join(sentences[best_match_index + 1:])
        
        # Форматирование заголовка в виде HTML-тега
        heading_tag = f'<h2>{heading}</h2><br>'
        
        # Объединяем части текста с вставленным заголовком
        new_text = before_sentence + heading_tag + after_sentence

        return new_text

    except ValueError as ve:
        logging.error(f"ValueError: {ve}")
        return f"Ошибка: {ve}"

    except RuntimeError as re:
        logging.error(f"RuntimeError: {re}")
        return f"Ошибка: {re}"

    except Exception as e:
        logging.error(f"Неизвестная ошибка: {e}")
        return "Произошла неизвестная ошибка при вставке заголовка."


# Определение места для вставки заголовков в текст
async def define_locations_for_headings(input_text: pd.DataFrame, headings: list[str]) -> dict[str, str]:
    tools = [
        {
            "type": "function",
            "function": {
                "name": "heading_insertion",
                "description": """
                
                    Анализ текста статьи для определения мест, где логично вставить заголовки для улучшения структуры и восприятия информации. 
                    
                    ### Требования ###:
                    - Места ДОЛЖНЫ быть расположены так, чтобы не нарушать логический поток текста.
                    - Места не должны быть непосредственно в конце текста.
                    - Добавляй места как они идут в изначальном списке. 
                
                """,
                "parameters": {
                    "type": "object",
                    "properties": {
                        "insert_locations": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "insert_location": {
                                        "type": "string",
                                        "description": "ТОЧНОЕ ДОСЛОВНОЕ словосочетание из текста статьи, после которого необходимо вставить заголовок. Возвращай дословную фразу из исходного текста статьи."
                                    }
                                },
                                "required": ["insert_location"]
                            },
                            "description": "Список мест в тексте для вставки заголовков"
                        }
                    },
                    "required": ["insert_locations"],
                    "additionalProperties": False,
                },
            }
        }
    ]

    results = {}
    
    list_of_headings = headings.strip().split('\n')

    # Перебор каждого заголовка из списка
    for heading in list_of_headings:
        prompt = f"""
        
            Проанализируй следующий текст и определи логическое место для вставки заголовка "{heading}".
            Заголовок должен быть вставлен так, чтобы сохранялась целостность и структура текста, а также улучшалась читабельность и восприятие материала.

            Место для заголовка должно быть логичным продолжением мысли предыдущего абзаца или подзаголовка, и не должно нарушать текущий поток текста.

            Формат вывода:
            Место для заголовка: <описание места в тексте для вставки заголовка>

            Текст статьи:
            {input_text}
            
        """
        
        completion = await client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "Ты — аналитик текста, который определяет места для вставки заголовков..."},
                {"role": "user", "content": prompt}
            ],
            tools=tools,
        )
        
        if completion.choices[0].finish_reason != 'tool_calls':
            results[heading] = "None"
            continue

        try:
            # Извлечение результата и добавление его в словарь с заголовком
            res = json.loads(completion.choices[0].message.tool_calls[0].function.arguments)["insert_locations"][0]["insert_location"]
            results[heading] = res
        except (KeyError, ValueError, TypeError) as e:
            logging.error(f"Ошибка при анализе результата: {e}")
            results[heading] = "Error"

    return results

async def generate_keywords_for_article_gpt(title: str) -> str:
    
    # Промт для генерации ключевых слов на основе названия статьи
    promt = """
        Generate 10 SEO-friendly keywords for an article titled: '{title}'. 
        
        Output the keywords in one line without numbering or bullet points, separated by a single space, without any line breaks.
        
    """.format(title=title)
    
    try:
        # Взаимодействие с OpenAI API для генерации ключевых слов
        # completion = client.chat.completions.create(
        #     # model="gpt-4o",  
        #     model="o1-preview",
        #     messages= [
        #         {
        #             "role": "user", 
        #             "content": promt
        #         }
        #     ]
        # )
        
        completion = await client.chat.completions.create(
        model="gpt-4o",
        messages=[
                {"role": "system", "content": "You are a professional SEO content writer."},
                {"role": "user", "content": promt}
            ]
        )
        
        # Возвращаем сгенерированные ключевые слова
        return str(completion.choices[0].message.content) 
    except Exception as e:
        print(f"Error during keyword generation: {e}")
        return ""
    
    
    
async def rewrite_keywords_title(title: str, keywords: str, total_tokens: int):
    
    # Промт для генерации ключевых слов на основе названия статьи
    prompt = f"""
        Ты являешься экспертом по SEO и оптимизации контента. Твоя задача — взять следующий заголовок статьи и список ключевых слов, проанализировать их, а затем переформулировать заголовок, органично добавив в него релевантные ключевые слова из списка для улучшения SEO.

        Заголовок статьи: '{title}'

        Ключевые слова: {keywords}

        Новый заголовок должен:
        - Включать 1-2 ключевых слова из списка, где это уместно (приоритетные ключевые слова следует использовать в первую очередь).
        - Сохранять естественный, увлекательный поток и соответствовать целевой аудитории (например, маркетологи, технические специалисты, широкая публика).
        - Избегать чрезмерного использования ключевых слов (keyword stuffing).
        - Оставаться понятным и легко воспринимаемым для читателей.
        - Заголовок должен быть ограничен 60 символами для оптимального отображения в поисковых системах.
        - Сохранять соответствующий стиль текста (например, профессиональный, разговорный, новостной).
        
         - !!! УБРАТЬ любое упоминание компании или организации, которая написала эту статью !!!

        Пожалуйста, верни ТОЛЬКО переформулированный заголовок в виде одного предложения, без ковычек, скобок и лишних слов.
    """
    
    try:
        # Взаимодействие с OpenAI API для генерации ключевых слов
        # completion = client.chat.completions.create(
        #     # model="gpt-4o",  
        #     model="o1-preview",
        #     messages= [
        #         {
        #             "role": "user", 
        #             "content": promt
        #         }
        #     ]
        # )
        
        completion = await client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "You are a professional SEO content writer."},
                {"role": "user", "content": prompt}
            ]
        )
        
        total_tokens += completion.usage.total_tokens
        
        # Возвращаем сгенерированные ключевые слова
        return str(completion.choices[0].message.content), total_tokens
    except Exception as e:
        print(f"Error during keyword generation: {e}")
        return "", total_tokens

# Асинхронная функция для фильтрации заголовков и добавления картинок
async def define_location_for_picture(input_text: pd.DataFrame) -> list[str]:
    tools = [
        {
            "type": "function",
            "function": {
                "name": "img_input",
                "description": "Анализ текста статьи для определения мест, где логично вставить изображение-мем для улучшения восприятия информации. Места определяются по введению новых концептов, описанию функций или эмоциональных моментов. Места ДОЛЖНЫ быть расположены равномерно по всему тексту!",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "mem_locations": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "insert_location": {
                                        "type": "string",
                                        "description": "ТОЧНОЕ ДОСЛОВНОЕ словосочетание из текста статьи, после которого необходимо вставить картинку-мем. Возвращай дословную фразу из исходного текста статьи."
                                    }
                                },
                                "required": ["insert_location"]
                            },
                            "description": "Список мест в тексте для вставки заголовка"
                        }
                    },
                    "required": ["mem_locations"],
                    "additionalProperties": False,
                },
            }
        }
    ]

    prompt = """
    
        Проанализируй следующий текст и определи ключевые моменты, где вводится новый концепт, 
        описываются важные функции, процессы или присутствует эмоциональная окраска текста.
        
        Определи, после каких заголовков или в каких моментах текста логичнее всего добавить мем, чтобы усилить восприятие или сделать текст более живым и понятным.
        
        На основе контекста текста создай описание для мема:
        - Если введен новый концепт, мем должен помогать визуализировать идею в юмористической форме.
        - Если текст описывает процесс или сложную функцию, мем может иллюстрировать преувеличенные последствия использования этой функции.
        - Если текст имеет эмоциональную окраску (например, трудности или радость), мем должен усиливать этот эмоциональный отклик с помощью юмора.
        
        Пример вывода:
        
        Место для мема: После подзаголовка "Основные возможности Gemini: модели Ultra, Pro, Flash и Nano с расширенным окном контекста".
        Описание картинки: Мем, на котором изображены четыре персонажа, символизирующие разные модели Gemini. Например, сильный супергерой для Ultra, быстрый персонаж для Flash, сбалансированный герой для Pro и миниатюрный персонаж для Nano. Подписи под персонажами усиливают различия между моделями, добавляя юмористический контекст.
        
        Формат вывода:
        Место для мема: <описание, после какого места в тексте вставить мем>
        Описание картинки: <текстовое описание мема, соответствующего контексту статьи>
        
        Текст статьи:{input_text}
        
    """.format(input_text=input_text)
    
    completion = await client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": "Ты — аналитик текста, который находит места для вставки мемов..."},
            {"role": "user", "content": prompt}
        ],
        tools=tools,
    )
    
    if completion.choices[0].finish_reason != 'tool_calls':
        return "None"

    try:
        res = json.loads(completion.choices[0].message.tool_calls[0].function.arguments)["mem_locations"]
        return res
    except (KeyError, ValueError, TypeError) as e:
        logging.error(f"Ошибка при анализе результата: {e}")
        return pd.DataFrame()
    
async def generate_keywords_for_article(url: str, title: str, session: aiohttp.ClientSession) -> str:
    
    try:
        
        se = "g_by"
        keywords = await serpstat.get_page_keywords(session, url, se)
        
        if not keywords:
            
            parsed_url = urlparse(url)
            domain = parsed_url.netloc
            keywords = await serpstat.get_page_keywords(domain, url, se)
            
            if not keywords:
                keywords = await generate_keywords_for_article_gpt(title)
                return keywords
            
            return keywords
        
        return keywords
        
    except Exception as e:
        print(f"Error during keyword generation: {e}")
        return ""

###############################################################################################################################################

# Обработчик ошибок
def log_error(message: str, error: Exception):
    logging.error(f"{message}: {error}")

async def gen_keyword_article(url: str, article_title: str, session: ClientSession) -> str:
    
    total_tokens = 0
    
    # try:
    #     # Парсинг контента статьи
    #     loader = UnstructuredURLLoader(urls=[url])
    #     content = loader.load()

    #     # Проверяем, что контент не пустой
    #     if content and content[0].page_content:
    #         article_content = content[0].page_content
    #     else:
    #         raise ValueError("Content_error: Статья пуста или не была загружена")

    # except Exception as e:
    #     log_error("Ошибка при парсинге контента статьи", e)
    #     return "Не удалось загрузить контент статьи."
    
    # try:
    # # Синхронный GET-запрос
    #     response = requests.get(url, timeout=10)
    #     response.raise_for_status()  # Проверяем, что запрос прошел успешно

    #     # Попытка установить правильную кодировку с заголовков ответа
    #     response.encoding = response.apparent_encoding

    #     # Получаем содержимое страницы
    #     text = response.text
    #     # Парсим содержимое страницы с помощью BeautifulSoup
    #     article_content = BeautifulSoup(text, 'html.parser')
        
    #     # Извлекаем заголовок статьи
    #     # article_title = soup.find('title').get_text() if soup.find('title') else "No Title Found"
    #     # print(f"Title of the article: {article_title}")

    # except requests.RequestException as e:
    #     print(f"Ошибка при запросе: {e}")


    article_content = """
            
        При организации кадрового электронного документооборота у работодателя остро встает вопрос защиты информации. Как обеспечить безопасность персональных данных сотрудников, как исключить доступ третьих лиц к локальным нормативным актам, как избежать утечки корпоративной информации?

        Читайте, каким образом организуется безопасность в КЭДО, какие инструменты применяются для повышения уровня защиты информации и документов, какие локальные акты в этой сфере утверждает работодатель.

        Для начала нужно определить, по каким именно направлениям должна обеспечиваться безопасность кадрового электронного документооборота. Можно выделить 3 таких направления:

        Сохранность документов, их безопасное хранение на сервере, защита персональных данных сотрудников.
        Ограничение прав доступа к информации – определение ролей пользователей в соответствии с их должностями и возможностью работы с электронными документами.
        Фиксирование действий пользователей с документами – отслеживание статуса, проверка подлинности подписания и пр.
        Обеспечение безопасности по всем перечисленным направлениям – обязанность оператора кадрового электронного документооборота. Инфраструктура оператора КЭДО должна удовлетворять требованиям Приказа ФСТЭК России от 18 февраля 2013 г. № 21 – в противном случае юридическое лицо не сможет стать оператором. Эти же требования необходимо соблюдать компании, если планируется хранить электронные документы на собственных серверах.

        Мнение эксперта. Большинство систем кадрового электронного документооборота могут быть развернуты как в облаке, так и на сервере клиента. В первом случае вся ответственность за безопасность КЭДО будет лежать на операторе, но это не означает, что из-за несоблюдения банальных мер безопасности работодатель не будет нести ответственность.

        Одним из направлений обеспечения безопасности в КЭДО является использование квалифицированных электронных подписей
        Одним из направлений обеспечения безопасности в КЭДО является использование квалифицированных электронных подписей
        Аутентификация при работе с сервисом КЭДО
        Реализация сервиса КЭДО может быть различной. Часто компании выбирают вариант, когда для кадровой службы используется модуль интеграции с учетной системой, а для рядовых сотрудников предоставляется доступ в личный кабинет через веб-версию. Аутентификация должна быть обязательно двухфакторной (например, логин и пароль, номер телефона и код из SMS), а вход в личный кабинет должен осуществляться через защищенное соединение HTTPS. Корпоративная политика в отношении паролей может включать в себя следующее:

        Регулярное изменение паролей сотрудников, запрет на использование одинаковых паролей для разных сервисов, систем, ПО.
        Использование разных символов и цифр в паролях.
        Запрет на хранение паролей в браузере рабочего компьютера.
        Вход в личный кабинет возможен с разных устройств, и работодатель физически не сможет контролировать сотрудников, поэтому базовые принципы безопасной работы с сервисом КЭДО можно отразить в локальном нормативном акте, ознакомить работников с документом под подпись.

        Сервис «Добыто. КЭДО» полностью удовлетворяет требованиям по безопасности – все кадровые документы надежно защищены, исключен доступ третьих лиц к документации и персональным данным сотрудников.

        Разграничение прав доступа к сервису КЭДО
        Каждая система кадрового электронного документооборота состоит из нескольких частей – как минимум, из 2-х компонентов. Первый компонент предназначен для кадровой службы, второй – для остальных сотрудников. Права в зависимости от роли будут отличаться:

        Кадровик – возможность создания, редактирования, удаления электронных документов, подписание документов посредством личной усиленной квалифицированной электронной подписи с машиночитаемой доверенностью. Также сотрудник кадровой службы может создавать шаблоны электронных документов, настраивать маршруты согласования, осуществлять массовую рассылку документов.
        Сотрудник – можно знакомиться с документами, отправленными для этого сотрудника, подписывать их посредством простой или усиленной неквалифицированной электронной подписи, заполнять шаблоны при отправке в кадровую службу типовых документов (например, заявление на отпуск).
        Кроме двух указанных ролей в системе кадрового электронного документооборота могут быть реализованы и другие роли – руководитель, администратор и пр. Руководитель может согласовывать электронные документы, подписывать их усиленной квалифицированной электронной подписью юридического лица, отправлять проекты документов на доработку. Администратор может отвечать за технический аспект системы КЭДО, отслеживать и сохранять все действия сотрудников в сервисе, предоставлять права для отдельных групп пользователей.

        Специалист кадровой службы в зависимости от предоставленных ему прав также может играть роль администратора – например, разрешать или запрещать отдельным категориям сотрудников создавать и редактировать шаблоны. Это удобно, когда в компании есть несколько обособленных структурных подразделений со своими кадровиками – в каждом филиале работники отдела кадров смогут создавать собственные шаблоны электронных документов.

        Мнение эксперта. В сервисе «Добыто. КЭДО» сотрудники могут выпускать УНЭП. Выпуск электронной подписи займет не более 10-15 минут, после чего работники смогут подписывать любые электронные документы, для которых в соответствии с действующим законодательством и локальными нормативными актами разрешено использование усиленной неквалифицированной электронной подписи.

        Несанкционированный доступ к личному кабинету защищен программой
        Несанкционированный доступ к личному кабинету защищен программой
        Электронные подписи и подлинность электронных документов
        На законодательном уровне использование электронной подписи регулируется законом № 63-ФЗ. В законе даются определения электронных подписей и общие принципы электронного документооборота. В плане безопасности КЭДО работодателю важно знать следующее:

        Рядовые сотрудники для подписания электронных документов могут пользоваться простой или усиленной неквалифицированной электронной подписью.
        Выпуск электронных подписей для сотрудников – обязанность работодателя.
        УНЭП сотрудников выпускают в удостоверяющем центре, но ряд сервисов КЭДО, например, система «Добыто. КЭДО» позволяет сделать это дистанционно прямо через личный кабинет.
        Работодатель, как представитель компании, подписывает документы усиленной квалифицированной электронной подписью юридического лица – получать УКЭП нужно только лично в ФНС.
        Кадровик при подписании кадровых документов от лица компании пользуется УКЭП физического лица и машиночитаемой доверенностью.
        Сотрудник при наличии личной УКЭП или УНЭП вправе пользоваться этой электронной подписью при подписании кадровых документов.
        Электронная подпись является аналогом собственноручной подписи только при выполнении нескольких условий. Во-первых, электронная подпись должна удовлетворять требованиям закона № 63-ФЗ. Во-вторых, в компании должен быть издан локальный нормативный акт, в котором оговорено условие, когда и какие виды электронных подписей могут быть признаны аналогами собственноручных подписей. На практике это означает, что при отсутствии соответствующего ЛНА работодатель или сотрудник могут оспорить любой электронный документ, подписанный простой или усиленной неквалифицированной электронной подписью. Усиленная квалифицированная электронная подпись всегда имеет юридическую силу, и оспорить электронные документы, подписанные УКЭП, нельзя.

        Где хранятся электронные документы?
        Сервис кадрового электронного документооборота – это онлайн-платформа, посредством которой при участии оператора КЭДО осуществляется обмен электронными документами. Сами документы могут храниться в облаке или на сервере работодателя. У каждого из вариантов есть как преимущества, так и недостатки:

        Хранение в облаке (модель SaaS). Не требуется установка и сложная настройка системы, не нужно выделять место для хранения файлов, в т.ч. архивных электронных документов (некоторые кадровые документы должны храниться до 75 лет после вывода из документооборота). Минус – обеспечение безопасности КЭДО осуществляет разработчик системы, и крупные компании не всегда хотят, чтобы доступ к персональным данным и документации был у третьей стороны.
        Хранение на собственном сервере (модель On-Premise). В среднем и крупном бизнесе, где работодатель может позволить себе содержать службу собственной безопасности, есть смысл в хранении электронных документов на собственных серверах. Минус – необходимо разворачивать систему на локальном хранилище, самостоятельно заниматься вопросами защиты информации.
        Сервис «Добыто. КЭДО» предоставляется как по модели SaaS, так и On-Premise. Клиент может сам выбрать подходящий вариант в зависимости от наличия подходящей инфраструктуры и требований по информационной безопасности.



        Человеческий фактор при обеспечении безопасности КЭДО
        Сотрудники должны знать основы информационной безопасности при работе с электронными документами и системой кадрового электронного документооборота. Чаще всего незнание, игнорирование основ приводит к серьезным проблемам, включая утечку информации. Часто в компаниях встречаются следующие проблемы:

        Сотрудники не завершают сеанс работы (не выходят из учетной записи), когда покидают кабинет.
        Работники знают пароли друг друга – нет гарантии, что конкретный электронный документ подпишет определенный сотрудник.
        Отсутствие антивирусного ПО на мобильном телефоне, где используется сервис КЭДО.
        Не стоит исключать и умышленное нарушение правил безопасности – например, когда сотрудник перед увольнением или из-за лишения премии пытается навредить работодателю. Логирование, т.е. запись логов (действий в системе) поможет отследить подозрительную активность и попытки несанкционированного доступа к кадровым электронным документам. В системе «Добыто. КЭДО» предусмотрена защита от несанкционированного доступа, инструменты отслеживания активности пользователей – исключен доступ третьих лиц к персональной информации, электронным документам.

        Мнение эксперта. Даже самая защищенная система кадрового электронного документооборота может оказаться уязвимой к опасностям из-за человеческого фактора. Информационная грамотность, обучение сотрудников основам безопасности – одно из важных направлений для защищенного от угроз кадрового ЭДО.

        Оператор ЭДО также отвечает за безопасность сведений и документов
        Оператор ЭДО также отвечает за безопасность сведений и документов
        Методы обеспечения безопасности КЭДО
        С технической точки зрения системы КЭДО являются достаточно защищенными, но это не означает, что компания не должна беспокоиться об информационной безопасности. Можно выделить несколько основных подходов для защищенного КЭДО. К таким подходам относится следующее:

        Использование усиленных электронных подписей. Простая электронная подпись практически не защищена, и с ее помощью подписать документ может любой человек, а не конкретный сотрудник. Использование УНЭП гарантирует, что электронный документ подпишет определенный сотрудник. В системе «Добыто. КЭДО» выпуск усиленных неквалифицированных электронных подписей для сотрудников осуществляется бесплатно.
        Отслеживание интернет-трафика. Установка фаерволов и межсетевых экранов позволяет работодателю отслеживать как входящий, так и исходящий сетевой трафик. При подозрительной активности можно предупредить атаки или попытки краж персональных данных.
        Резервное копирование документов. Необходимо регулярно копировать электронные документы, хранить их на локальных хранилищах. При наличии резервных копий восстановление в случае атаки, повреждения оборудования не вызовет проблем.
        Антивирусное ПО. На рынке представлено большое количество антивирусных программ – не стоит экономить на этом простом, но достаточно действенном инструменте обеспечения информационной безопасности.
        Не забывайте про регулярное обновление программ и сервисов. Разработчики при выпуске обновления и патчей не только улучшают функционал программ, но и устраняют возможные уязвимости. Как правило, обновления системы КЭДО проходят незаметно для пользователей – не требуется вручную обновлять программное обеспечение. Исключение – модули интеграции, когда при выпуске нового обновления может потребоваться установка (интеграция) обновленной версии.

        Преимущества сервиса «Добыто. КЭДО»
        Система кадрового электронного документооборота «Добыто. КЭДО» предназначена для внутреннего обмена кадровыми документами, их формирования и подписания. В системе реализованы все инструменты для безопасного КЭДО.

        Среди плюсов сервиса «Добыто. КЭДО» можно отметить следующее:

        Хранение документов в сертифицированном дата-центре – соответствие ГОСТ 57580, 152-ФЗ, ISO 27001/27017/27018/ 27701, PCI.
        Выпуск ПЭП и УНЭП для сотрудников (бесплатно).
        Возможность работы с кадровыми электронными документами без интернета.
        Для кадровой службы предусмотрен модуль интеграции с учетными системами. Можно работать в 1С:ЗУП или Битрикс24 – кадровику не потребуется изучать новое программное обеспечение для КЭДО.

        Системы криптографической защиты позволяют защитить персональные данные граждан
        Системы криптографической защиты позволяют защитить персональные данные граждан
        Заключение
        Безопасность в КЭДО обеспечивается как со стороны оператора кадрового электронного документооборота, так и со стороны работодателя.
        Сервис «Добыто. КЭДО» позволяет безопасно обмениваться кадровыми документами – он полностью удовлетворяет требованиям российского законодательства.
        Сервис может использоваться для юридически значимой документации, в т.ч. для трудовых договоров, личных карточек сотрудников и других документов, содержащих персональные данные.
        Вопросы и ответы
        Возможна ли кража или утеря электронных документов при облачном хранении?

        Оператор КЭДО имеет все необходимые технические возможности для защиты информации. В сервисе «Добыто. КЭДО» все электронные документы хранятся на серверах, расположенных на территории РФ. Регулярно создаются резервные копии всей информации, поэтому исключена утеря электронных документов.

        Может ли кадровик подписывать документы от лица руководителя?

        Нет. Во-первых, пользоваться чужой электронной подписью для подписания документов запрещено. Во-вторых, руководитель в качестве юридического лица подписывает документы только своей УКЭП. Специалисты кадровой службы для подписания юридически значимых документов пользуются личной УКЭП и машиночитаемой доверенностью.

        Сотрудник увольняется – он будет иметь доступ к системе КЭДО?

        Нет – достаточно удалить такого сотрудника из системы. Сделать это может кадровик через модуль «Добыто. КЭДО». После удаления сотрудника из списка доступ к системе будет прекращен. Не забывайте своевременно удалять и добавлять сотрудников в систему – это еще один из инструментов обеспечения безопасности кадрового электронного документооборота.
        
    """

    try:
        # Промт удаления рекламы
        plan_query = f"""
        
            ### Роль ###:
                - Действуй как профессиональный аналитик текста.
                - Ты должен обработать предоставленный текст и выполнить следующие шаги, не изменяя исходный текст, за исключением удаления предложений, связанных с названием компании, её рекламой и заголовков.
                
            ### Требования ###:
                - В итоговый вывод ДОБАВЬ ТОЛЬКО изначальный текст, отфильтрованный от предложений, которые относятся к названию компании, её рекламы и заголовков.
                - НЕ ВЫВОДИ свои рассуждения, а ВЫВЕДИ ТОЛЬКО итоговый отфильтрованный текст.
                Сохраняй полностью структуру и содержание изначального текста за исключением удаленных частей.
                
            ### Инструкция ###:
                - Определи название компании: 
                    Используй только текст URL, не переходя по ссылке. Определи название компании по основному домену и ключевым словам в URL. Игнорируй поддомены и любые параметры после основного URL. Если в URL не содержится явно название компании, постарайся извлечь его по тематике или ключевым словам.
                    
                    Пример: для URL www.example.com/shop-offers названием компании будет "Example".
                    
                - Найди упоминания компании и её рекламу в тексте:

                    После того как определишь название компании, найди все упоминания этого названия в тексте.
                    Также найди предложения, связанные с рекламой этой компании (например, упоминания скидок, акций, специальных предложений).
                    
                    Пример рекламных предложений: "Скидка 50% на все товары компании Example", "Закажите сейчас и получите бесплатную доставку от Example".
                
                - Найди заголовки:
                    Определи и удали заголовки из текста (обычно заголовки выделены как отдельные строки (пустая строка с каждой стороны), начинающиеся с заглавной буквы или номера и небольшой длинны).
                    Заголовки могут быть основными (H1, H2, H3) или промежуточными разделами.
                
                - Фильтрация текста:
                    Удали все предложения, где есть упоминания названия компании и реклама.
                    Удали все заголовки, чтобы сохранить только текстовую часть статьи.
                    Оставь все остальные части текста без изменений.
                
                - Верни итоговый текст:
                    Верни исходный текст, из которого удалены все предложения, связанные с названием компании, рекламой и заголовки. Не добавляй собственных рассуждений или выводов.
                
            ### Данные на вход ###:
                - Текст на вход: {article_content}
                - URL страницы: {url}

        """
        
        response = await client.chat.completions.create(
        #     model="o1-preview",
        #     messages=[{"role": "user", "content": plan_query}]
        # )
        
        model="gpt-4o",
        messages=[
                {"role": "system", "content": "You are a professional SEO content writer."},
                {"role": "user", "content": plan_query}
            ]
        )
        total_tokens += response.usage.total_tokens
        
        article_content = str(response.choices[0].message.content)
        print(article_content)
        article_content_len = len(article_content)

    except Exception as e:
        log_error("Ошибка при генерации плана статьи с помощью OpenAI", e)
        return "Не удалось сгенерировать план статьи."
    
    try:
        # Промт для выделения плана
        plan_query = f"""
            <tag>
                **Роль**: Ты выступаешь в роли **опытного аналитика и редактора**, который умеет работать с текстами разного формата. Твоя задача — проанализировать текст статьи и на его основе составить структурированный план. План должен отражать основную логику и ключевые разделы текста, сохраняя последовательность идей и структуры статьи.
            </tag>

            <tag>
                **Задача**: Получив текст статьи на вход, тебе необходимо составить план статьи, придерживаясь следующих рекомендаций:

                !!! СОБЛЮДАЙ ВСЕ ПРОПИСАННЫЕ ТРЕБОВАНИЯ В СЛЕДУЮЩЕМ РАЗДЕЛЕ !!!
            </tag>

            <tag>
                **Требования**:

                1. **Структурированность**: План должен быть логически выстроенным и отражать основные разделы статьи. Обозначь каждый пункт плана кратким описанием идеи или основного тезиса, заложенного в статье.
                
                2. **Иерархия**: План должен иметь ясную иерархию. Главные разделы (основные пункты плана статьи) статьи следует ОБЯЗАТЕЛЬНО обозначить в следущем формате: **Название раздела (пункта)**
                - НЕ ИСПОЛЬЗУЙ ПОДЗАГОЛОВИК, ПОДПУНКТЫ. ПЛАН ДОЛЖЕН СОСТОЯТЬ ТОЛЬКО ИЗ ОСНОВНЫХ РАЗДЕЛОВ. 
                - Не добавляй в заголовки шаблонные фразы, например введение, заключение, вывод, начало и другие
                - План ДОЛЖЕН включать в себя НЕ более 5 разделов (пунктов)
                
                3. **Последовательность**: Структура плана должна следовать за логикой и структурой оригинальной статьи. Учитывай введение, основную часть и заключение, даже если они не выделены явно в тексте.

                4. **Лаконичность**: Старайся не перегружать план деталями. Кратко излагай основную мысль каждого раздела статьи, сохраняя общий смысл текста.
                
                5. **Вывод информации**: 
                    - Выводи ОБЯЗАТЕЛЬНО исключительно план статьи, без других элементов, например фраз "план статьи" и других
                    - Выводи план на русском.
                    - Не используй между пунктами плана пробел.
                    - Каждый пункт плана выделяй с двух сторон символом (переходом на следующую строку и ** в начале и в конце) \n**
                    - Каждый новыц пункт плана, начинать с новой строки!
                    - Между ОБЯЗАТЕЛЬНО пунктами плана не добавляй enter
            </tag>

            <tag>
                **Текст статьи на вход**: ["{article_content}"]
            </tag>
        """
        
        response = await client.chat.completions.create(
        #     model="o1-preview",
        #     messages=[{"role": "user", "content": plan_query}]
        # )
        
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "You are a professional SEO content writer."},
                {"role": "user", "content": plan_query}
            ]
        )
        
        total_tokens += response.usage.total_tokens
        
        article_plan = response.choices[0].message.content
        print(f"План статьи: {article_plan}")

    except Exception as e:
        log_error("Ошибка при генерации плана статьи с помощью OpenAI", e)
        return "Не удалось сгенерировать план статьи."

    # try:
    #     # Промт для написания первичной статьи
    #     article_query = """
    #         <tag>
    #             **Роль**: Ты выступаешь в роли **опытного редактора и автора**, который умеет перерабатывать статьи, сохраняя их структуру и ключевые идеи. Твоя задача — написать новую статью, следуя предложенному плану и улучшая исходный материал.
    #         </tag>

    #         <tag>
    #             **Задача**: На основе исходной статьи по представленному тебе плану, строго ему придерживаясь (В ТЕКСТЕ НИКАК НЕ ПОМЕЧАЙ ПОДПУНКТЫ), тебе необходимо написать новую статью, строго придерживаясь следующих требований:

    #             !!! СТРОГО СОБЛЮДАЙ ВСЕ ПРОПИСАННЫЕ ТРЕБОВАНИЯ В СЛЕДУЮЩЕМ РАЗДЕЛЕ !!!
    #         </tag>

    #         <tag>
    #             **Требования**:
            
    #                 ### 1. Следование плану:
    #                 - Чётко следуй предложенной структуре, используя план как основу новой статьи.
    #                 - Каждый пункт плана должен быть максимально подробно и полно (ОБЯЗАТЕЛЬНО добавляй ИЗБЫТОЧНОЕ количество полезного контента) раскрыт в отдельном разделе текста.
    #                 - Длинна итогового текста ДОЛЖНА СОСТАВЛЯТЬ {text_len} символов. ДАННОН ТРЕБОВАНИК !!!ОБЯЗАТЕЛЬНОЕ!!!

    #                 ### 2. Оригинальность:
    #                 - Переписывание своими словами: Используй исходную статью как основу для анализа, но пиши текст от себя, как автор. Это поможет избежать однообразия и придаст тексту индивидуальность.
    #                 Избегание копий: Никогда не копируй фразы или предложения из исходного текста. Всегда старайся передавать идеи по-своему, так, чтобы новый текст был полностью уникален.
    #                 - Эмоциональные акценты и примеры: Добавляй живые примеры и метафоры, которые отражают твою личную точку зрения и глубину анализа темы. Вместо того чтобы просто пересказывать, постарайся показать своё видение, делая статью более запоминающейся и интересной.
    #                 Избегание клише: Уходи от формальных клише и шаблонных выражений, которые часто встречаются в нейтральных текстах. Введи разнообразие в язык и стиль, чтобы читатель чувствовал увлечённость и энергию в тексте.
    #                 - Разнообразие подачи: Используй разные синтаксические конструкции, чередуй короткие и длинные предложения, чтобы текст был динамичным и удерживал внимание. Это избавит от однообразия и перегруженности.
                    
    #                 ### 3. Углубление материала:
    #                 - Добавление анализа и примеров: Каждая часть статьи должна быть тщательно проработана. Вместо поверхностного рассмотрения темы углубляйся в детали, давая чёткие и актуальные примеры, которые помогут читателю лучше понять материал.
    #                 - Аналитические выводы: Если исходный текст недостаточно глубок, дополняй его собственными выводами и анализом. Включай примеры из реальной жизни или отраслевые кейсы, которые обогащают текст и делают его полезным для читателя.
    #                 - Баланс деталей: Важно избегать перегрузки текста избыточной информацией. Стремись к тому, чтобы каждая деталь усиливала основную мысль, а не отвлекала от неё.
                    
    #                 ### 4. Стиль и язык:
    #                 - Профессионализм и доступность: Пиши на русском языке в профессиональном, но доступном стиле, ориентируясь на широкую аудиторию. Убедись, что текст легко воспринимается как специалистами, так и теми, кто только знакомится с темой.
    #                 - Ясность и простота: Избегай сложных и громоздких предложений. Чётко и ясно излагай мысли, разбивая длинные абзацы на более компактные, чтобы улучшить читаемость.
    #                 - Акцент на уникальность: Используй собственный голос, чтобы текст был интересным, избегай механистичности и сухого изложения. Это придаст тексту индивидуальность и повысит его ценность для аудитории.

    #                 ### 5. Логичность и структура:
    #                 - Следи за плавным переходом между разделами, обеспечивая логическую связь между ними.
    #                 - Используй введение для представления темы и заключение для подведения итогов статьи. НЕ ИСПОЛЬЗУЙ слово "заключение, таким образом, в итоге, наконец, и так " в тексте нигде! и другие шаблонные слова для начала заключительной части.
    #                 - В тексте должны быть только пункты пердставленого плана, !!!НИКАКИХ ДРУГИХ ПОДПУНКТОВ!!!
    #                 - НЕ выводи название стать, автора, ссылки на другие статьи, описание темы, содержание, комментарии
    #                 - УБРТЬ из текста упоминание компании, которая напсиала данную статью, любую саморекламу
    #                 - ОБЯЗАТЕЛЬНО УБРАТЬ со всего текста любую рекламу
                    
    #                 ### 6. Дополнительные требования:
    #                 -  СПИСКИ: При добавлении любых списков, формат списков ДОЛЖЕН быть следующий: - (нет вводного слова или фразы, а сразу контент пункта) Контекнт пункта списка. Следуй данному пункту ОБЯЗАТЕЛЬНО!!!
    #         </tag>

    #         <tag>
    #             **План статьи на вход**: ["{article_plan}"]
    #             **Текст статьи на вход**: ["{article_content}"]
    #         </tag>
    #     """.format(text_len=len(article_content), article_content=article_content, article_plan=article_plan)

    #     response = await client.chat.completions.create(
    #         # model="o1-preview",
    #     #     model="o1-mini",
    #     #     messages=[{"role": "user", "content": article_query}]
    #     # )
        
    #     model="gpt-4o",
    #     messages=[
    #             {"role": "system", "content": "You are a professional SEO content writer."},
    #             {"role": "user", "content": article_query}
    #         ]
    #     )
        
    #     initial_article = response.choices[0].message.content
    #     # print(f"\n\n Первоначальная статья = \n\n{initial_article}\n\n")

    # except Exception as e:
    #     log_error("Ошибка при генерации первичной статьи с помощью OpenAI", e)
    #     return "Не удалось сгенерировать первичную статью."
    
    tools = [
        {
            "type": "function",
            "function": {
                "name": "analyze_text_meanings",
                "description": "Analyze the input text, count distinct, non-overlapping meanings, and extract key sentences without losing any part of the text.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "meanings": {
                            "type": "array",
                            "description": "List of distinct (minimum 5 in the all text), non-overlapping meanings extracted from the text, each with ONLY a start and end sentence. Ensure NO part of the text is lost between meanings.",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "start_sentence": {
                                        "type": "string",
                                        "description": "ONLY first sentence of the meaning."
                                    },
                                    "end_sentence": {
                                        "type": "string",
                                        "description": "ONLY last sentence of the meaning."
                                    },
                                    "block_text": {
                                        "type": "string",
                                        "description": "The full text of the meaning block, ensuring no part of the text is lost between meanings."
                                    }
                                },
                                "required": ["start_sentence", "end_sentence", "block_text"],
                            }
                        },
                        "count": {
                            "type": "integer",
                            "description": "Total number of distinct, non-overlapping meanings found."
                        }
                    },
                    "required": ["meanings", "count"],
                    "additionalProperties": False,
                }
            }
        }
    ]
    
    prompt = (
        f"Analyze the following text:\n\n{article_content}\n\n"
        "1. Identify distinct meanings in the text. Ensure each meaning is clearly separated, non-overlapping, and that no part of the text is lost.\n"
        "2. For each meaning, return its first and last sentences, and the entire block of text that constitutes that meaning. Preserve the continuity of the text between meanings.\n"
        "3. Provide the total number of meanings and a list of objects, where each object contains the first and last sentences of the meaning, and the full text of the block."
    )

    response = await client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": "You are a link analyzer"},
            {"role": "user", "content": prompt}
        ],
        tools=tools,
    )
    
    total_tokens += response.usage.total_tokens

    if response.choices[0].finish_reason != 'tool_calls':
        return ""

    try:
        initial_article = json.loads(response.choices[0].message.tool_calls[0].function.arguments)["meanings"]
    except (KeyError, ValueError, TypeError) as e:
        print(f"Ошибка при анализе результата: {e}")    
    
    
    block_texts = []

    # Loop through each object and extract block_text
    for meaning in initial_article:
        block_texts.append(meaning["block_text"])
        
    # print(block_texts)
    
    rewrite_article_content = str(" ")
    
    for section in block_texts:
        # Здесь можно выполнить любое действие для каждого элемента
        
        article_query = f"""
        
            <tag>
                **Роль**: Ты выступаешь в роли **опытного редактора и автора**, который умеет перерабатывать статьи, сохраняя их структуру и ключевые идеи. Твоя задача — переписать фрагмент текста соответствуя правилам и улучшая исходный материал.
            </tag>

            <tag>
                **Задача**: На основе исходного фрагмента текста, тебе необходимо переписать изначальный текст, строго придерживаясь следующих требований:

                !!! СТРОГО СОБЛЮДАЙ ВСЕ ПРОПИСАННЫЕ ТРЕБОВАНИЯ В СЛЕДУЮЩЕМ РАЗДЕЛЕ !!!
            </tag>

            <tag>
                **Требования**:
            
                    ### 1. Следование плану:
                    - Каждый акпект изначального текста должен быть максимально подробно и полно (ОБЯЗАТЕЛЬНО добавляй ИЗБЫТОЧНОЕ количество полезного контента) раскрыт в отдельном разделе текста.
                    - Длинна итогового текста ДОЛЖНА СОСТАВЛЯТЬ {len(section)} символов. ДАННОН ТРЕБОВАНИЕ !!!ОБЯЗАТЕЛЬНОЕ!!!

                    ### 2. Оригинальность:
                    - Переписывание своими словами: Используй исходный текст как основу для анализа, но пиши текст от себя, как автор. Это поможет избежать однообразия и придаст тексту индивидуальность.
                    Избегание копий: Никогда не копируй фразы или предложения из исходного текста. Всегда старайся передавать идеи по-своему, так, чтобы новый текст был полностью уникален.
                    - Эмоциональные акценты и примеры: Добавляй живые примеры и метафоры, которые отражают твою личную точку зрения и глубину анализа темы. Вместо того чтобы просто пересказывать, постарайся показать своё видение, делая статью более запоминающейся и интересной.
                    Избегание клише: Уходи от формальных клише и шаблонных выражений, которые часто встречаются в нейтральных текстах. Введи разнообразие в язык и стиль, чтобы читатель чувствовал увлечённость и энергию в тексте.
                    - Разнообразие подачи: Используй разные синтаксические конструкции, чередуй короткие и длинные предложения, чтобы текст был динамичным и удерживал внимание. Это избавит от однообразия и перегруженности.
                    
                    ### 3. Углубление материала:
                    - Добавление анализа и примеров: Каждая часть статьи должна быть тщательно проработана. Вместо поверхностного рассмотрения темы углубляйся в детали, давая чёткие и актуальные примеры, которые помогут читателю лучше понять материал.
                    - Аналитические выводы: Если исходный текст недостаточно глубок, дополняй его собственными выводами и анализом. Включай примеры из реальной жизни или отраслевые кейсы, которые обогащают текст и делают его полезным для читателя.
                    - Баланс деталей: Важно избегать перегрузки текста избыточной информацией. Стремись к тому, чтобы каждая деталь усиливала основную мысль, а не отвлекала от неё.
                    
                    ### 4. Стиль и язык:
                    - Профессионализм и доступность: Пиши на русском языке в профессиональном, но доступном стиле, ориентируясь на широкую аудиторию. Убедись, что текст легко воспринимается как специалистами, так и теми, кто только знакомится с темой.
                    - Ясность и простота: Избегай сложных и громоздких предложений. Чётко и ясно излагай мысли, разбивая длинные абзацы на более компактные, чтобы улучшить читаемость.
                    - Акцент на уникальность: Используй собственный голос, чтобы текст был интересным, избегай механистичности и сухого изложения. Это придаст тексту индивидуальность и повысит его ценность для аудитории.

                    ### 5. Логичность и структура:
                    - Следи за плавным переходом между разделами, обеспечивая логическую связь между ними.
                    - НЕ ИСПОЛЬЗУЙ слово "заключение, таким образом, в итоге, наконец, и так " в тексте нигде! и другие шаблонные слова для начала заключительной части.
                    - НЕ выводи название стать, автора, ссылки на другие статьи, описание темы, содержание, комментарии
                    - УБРАТЬ из текста упоминание компании, которая написала данную статью, любую саморекламу
                    - ОБЯЗАТЕЛЬНО УБРАТЬ со всего текста любую рекламу
                    - !!! НЕ ДОБАВЛЯЙ в текст никакие абзатцы !!!
                    
                    ### 6. Дополнительные требования:
                    -  СПИСКИ: При добавлении любых списков, формат списков ДОЛЖЕН быть следующий: - (нет вводного слова или фразы, а сразу контент пункта) Контекнт пункта списка. Следуй данному пункту ОБЯЗАТЕЛЬНО!!!
            </tag>

            <tag>
                **Текст на вход для рерайта**: ["{section}"]
            </tag>
        ""
            
        """
        
        response = await client.chat.completions.create(
        #     model="o1-preview",
        #     messages=[{"role": "user", "content": plan_query}]
        # )
        
            model="gpt-4o",
            messages=[
                    {"role": "system", "content": "You are a professional SEO content writer."},
                    {"role": "user", "content": article_query}
                ]
        )
        
        total_tokens += response.usage.total_tokens
        
        article = str(response.choices[0].message.content)
        rewrite_article_content += article
        
        print(f"Количество символов в изначальном тексте: {article_content_len} символов.\nКоличество символов в итоговом тексте: {len(rewrite_article_content)} символов.\nПотери в %: {((len(rewrite_article_content) - article_content_len) / article_content_len) * 100}")
    
    print(rewrite_article_content)
    
    ###########################################################################################################################
    # Добавление ключевых слов
    ###########################################################################################################################

    # Предполагается, что `generate_keywords_for_article` — это функция для получения ключевых слов через API (например, Serpstat)
    try:
        # Список ключевых слов, который генерируется по заголовку статьи
        keywords = await generate_keywords_for_article(url, article_title, session)

        # Генерация финальной статьи с учетом ключевых слов
        keyword_insertion_query = f"""
        
            ### Роль ###: 
                - Ты — опытный SEO-специалист. Твоя задача — добавить в текст ключевые слова, строго придерживаясь указанных правил.

            ### Задача ###:
                - Твоя основная задача — встроить ключевые слова в исходный текст статьи, не изменяя его объем и структуру. 
                
                !!! СТРОГО ЗАПРЕЩАЕТСЯ удалять или сокращать оригинальный текст !!! 
                
                Ключевые слова должны быть добавлены естественно, без нарушения целостности текста и без их выделения. Текст должен полностью сохранить свою исходную длину.

            ### Требования ###:
                ## Интеграция ключевых слов ##:
                    - Поддерживай плотность ключевых слов на уровне 1-2%, но не нарушай объем текста.
                    - Никакие ключевые слова не должны выделяться или отличаться от основного текста. Они должны быть органично вписаны в текст.
                    - Запрещается изменять или удалять исходные элементы текста.
                    Объем текста:

                    - Объем текста должен остаться точно таким же — {len(rewrite_article_content)} символов.
                    - Ты можешь добавлять примеры или уточнения, чтобы естественно вписать ключевые слова, но текст не должен быть короче исходного объема.
                    
                    # Язык и стиль #:
                        - Весь текст должен оставаться на русском языке.
                        - Пиши текст в том же стиле, который использован в исходной статье, чтобы сохранить его целостность.
                
            ### Входные данные ###:
                - Ключевые слова: {keywords}
                - Текст статьи: {rewrite_article_content}
            
        """

        response = await client.chat.completions.create(
        #     model="o1-preview",
        #     messages=[{"role": "user", "content": keyword_insertion_query}]
        # )
        
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "You are a professional SEO content writer."},
                {"role": "user", "content": keyword_insertion_query}
            ],
            # temperature=0.8
        )
        
        total_tokens += response.usage.total_tokens

        key_words_article = response.choices[0].message.content
        print(f"Статья с ключевыми словами = {key_words_article}")
            
    except Exception as e:
        log_error("Ошибка при получении ключевых слов", e)
        return "Не удалось получить ключевые слова для статьи."
    
    # Добавление обзатцев
    # try:

    #     # Добавление абзацев
    #     keyword_insertion_query = f"""
            
    #         ### Роль ###:
    #             - Действуй как профессиональный редактор контента.
    #             - Ты — эксперт в структурировании и форматировании длинных текстов. Твоя цель — взять предоставленную статью и вставить в неё конкретные заголовки разделов без изменения или модификации исходного текста.
            
    #         ### Цель ###: 
    #             - Сохрани целостность оригинального текста: Текст должен остаться таким, как он был, без каких-либо изменений в формулировках, пунктуации или структуре предложений.
    #             - Длинна итогового текста ДОЛЖНА СОСТАВЛЯТЬ не менее {len(rewrite_article_content)} символов. Объем текста не должен сокращаться.
    #             - Вставь заголовки разделов: Помести данные заголовки в статью в логичных местах. Заголовки можно добавлять только там, где они естественно вписываются в смысл текста.
    #             - ТЕКСТ не должен сокращаться: Нельзя удалять части текста, каждый элемент оригинального текста должен остаться в статье.
    #             - Никак не изменяй заголовки, сохраняй символы **.
    #             - Заголовки должны быть добавлены так, чтобы сохранялась логика и читаемость статьи.
                
    #         ### Входные данные ###:
    #             - Заголовки для вставки: {article_plan}
    #             - Изначальный текст: {key_words_article}
            
    #         ### Инструкция ###:
    #             - Возьми исходный текст статьи и заголовки, затем шаг за шагом вставь заголовки в текст, не изменяя или модифицируя исходный текст. 
    #             - Обязательно убедись, что общий объем текста не сокращается. Если необходимо, добавляй пояснения для улучшения потока текста.
    #             - Выводи ТОЛЬКО итоговый текст.
                
    #     """

    #     response = await client.chat.completions.create(
    #     #     model="o1-preview",
    #     #     messages=[{"role": "user", "content": keyword_insertion_query}]
    #     # )
        
    #         model="gpt-4o",
    #         messages=[
    #             {"role": "system", "content": "You are a professional SEO content writer."},
    #             {"role": "user", "content": keyword_insertion_query}
    #         ]
    #     )
        
    #     total_tokens += response.usage.total_tokens

    #     key_words_article = response.choices[0].message.content
    #     print(f"Статья с ключевыми словами = {key_words_article}")
        
    #     keywords_article_title, total_tokens = await rewrite_keywords_title(article_title, keywords, total_tokens)
        
    #     print(f"total_tokens = {total_tokens}")
    #     print(f"Количество символов в изначальном тексте: {article_content_len} символов.\nКоличество символов в итоговом тексте: {len(key_words_article)} символов.\nПотери в %: {((len(key_words_article) - article_content_len) / article_content_len) * 100}")
    #     print(f"Ключевые слова: {keywords}")
    
    # except Exception as e:
    #     log_error("Ошибка при получении ключевых слов", e)
    #     return "Не удалось получить ключевые слова для статьи."
    
    try:
        # Добавление абзацев
        # result = await define_locations_for_headings(input_text=key_words_article, headings=article_plan)
        
        # if not result:
        #     raise ValueError("Не удалось найти места для вставки заголовков.")
        
        # print(result)
        
        # list_of_headings = article_plan.strip().split('\n')
        
        # # Выводим результат для проверки
        # for heading, location in result.items():
        #     if location:
        #         key_words_article = await insert_heading_after_semantic_phrase(text=key_words_article, phrase=location, heading=heading)
        #         print(f"Заголовок: {heading}, Место вставки: {location}")
        #     else:
        #         print(f"Не удалось найти место для заголовка: {heading}")
        
        keywords_article_title, total_tokens = await rewrite_keywords_title(article_title, keywords, total_tokens)
        
        print(f"total_tokens = {total_tokens}")
        print(f"Количество символов в изначальном тексте: {article_content_len} символов.\n"
            f"Количество символов в итоговом тексте: {len(key_words_article)} символов.\n"
            f"Потери в %: {((len(key_words_article) - article_content_len) / article_content_len) * 100}")
        print(f"Ключевые слова: {keywords}")

    except ValueError as ve:
        log_error("Ошибка при обработке заголовков", ve)
        return "Ошибка: некорректные данные для вставки заголовков."
    except Exception as e:
        log_error("Ошибка при получении ключевых слов", e)
        return "Не удалось получить ключевые слова для статьи."

    return key_words_article, keywords_article_title

